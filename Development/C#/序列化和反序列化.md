序列化和反序列化
构造 [DataContractSerializer](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.datacontractserializer(v=vs.110).aspx) 的实例是一个重要步骤。完成构造后，将不能够更改任何设置。

### 

[指定根类型](# "折叠")

根类型是序列化或反序列化实例的类型。 [DataContractSerializer](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.datacontractserializer(v=vs.110).aspx) 有许多构造函数重载，但必须使用 *type* 参数提供至少一个根类型。

为某个根类型创建的序列化程序不能用于序列化（或反序列化）其他类型，除非该类型是从根类型派生的。下面的示例演示了两个类。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-1)

```
[DataContract]
public class Person
{
    // Code not shown.
}

[DataContract]
public class PurchaseOrder
{
    // Code not shown.
}
```

此代码构造 **DataContractSerializer** 的一个实例，它仅可用于序列化或反序列化 Person 类的实例。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-2)

```
DataContractSerializer dcs = new DataContractSerializer(typeof(Person));
//This can now be used to serialize/deserialize Person but not PurchaseOrder.
```

### 

[指定已知类型](# "折叠")

如果在进行序列化的类型中涉及多态性并且尚未使用 [KnownTypeAttribute](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.knowntypeattribute(v=vs.110).aspx) 属性或一些其他机制进行处理，则必须使用 *knownTypes* 参数将可能的已知类型的列表传递给序列化程序的构造函数。有关以下内容的详细信息已知类型的更多信息，请参见[数据协定已知类型](https://msdn.microsoft.com/zh-cn/library/ms730167(v=vs.110).aspx)。

下面的示例演示 LibraryPatron 类，该类包含特定类型 LibraryItem 的集合。第二个类定义 LibraryItem 类型。第三个和第四个类（Book 和 Newspaper）从 LibraryItem 类继承。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-3)

```
[DataContract]
public class LibraryPatron
{
    [DataMember]
    public LibraryItem[] borrowedItems;
}
[DataContract]
public class LibraryItem
{
    //code not shown
}

[DataContract]
public class Book : LibraryItem
{
    //code not shown
}

[DataContract]
public class Newspaper : LibraryItem
{
    //code not shown
}
```

下面的代码构造一个使用 *knownTypes* 参数的序列化程序的实例。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-4)

```
//Create a serializer for the inherited types using the knownType parameter.
Type[] knownTypes = new Type[] { typeof(Book), typeof(Newspaper) };
DataContractSerializer dcs =
new DataContractSerializer(typeof(LibraryPatron), knownTypes);
// All types are known after construction.
```

### 

[指定默认根名称和命名空间](# "折叠")

通常，在对对象进行序列化时，将根据数据协定名称和命名空间确定最外面的 XML 元素的默认名称和命名空间。所有内部元素的名称将根据数据成员名称来确定，这些元素的命名空间是数据协定的命名空间。下面的示例设置 [DataContractAttribute](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.datacontractattribute(v=vs.110).aspx) 和 [DataMemberAttribute](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.datamemberattribute(v=vs.110).aspx) 类的构造函数中的 Name 和 Namespace 值。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-5)

```
[DataContract(Name = "PersonContract", Namespace = "http://schemas.contoso.com")]
public class Person2
{
    [DataMember(Name = "AddressMember")]
    public Address theAddress;
}

[DataContract(Name = "AddressContract", Namespace = "http://schemas.contoso.com")]
public class Address
{
    [DataMember(Name = "StreetMember")]
    public string street;
}
```

对 Person 类的实例进行序列化将生成类似如下的 XML。

```
<PersonContract xmlns="http://schemas.contoso.com">
  <AddressMember>
    <StreetMember>123 Main Street</StreetMember>
   </AddressMember>
</PersonContract>
```

但是，可以通过将 *rootName* 和 *rootNamespace* 参数的值传递到 [DataContractSerializer](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.datacontractserializer(v=vs.110).aspx) 构造函数，自定义根元素的默认名称和命名空间。注意，*rootNamespace* 不会影响对应于数据成员的所包含元素的命名空间，而只是影响最外面元素的命名空间。

可以作为字符串或 [XmlDictionaryString](https://msdn.microsoft.com/zh-cn/library/system.xml.xmldictionarystring(v=vs.110).aspx) 类的实例来传递这些值，从而允许使用二进制 XML 格式对其进行优化。

### 

[设置最大对象配额](# "折叠")

一些 **DataContractSerializer** 构造函数重载具有 *maxItemsInObjectGraph* 参数。此参数确定序列化程序在单个 [ReadObject](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.xmlobjectserializer.readobject(v=vs.110).aspx) 方法调用中序列化或反序列化的对象的最大数目。（该方法总是读取一个根对象，但此对象的数据成员中可以具有其他对象。这些对象又可以具有其他对象，依此类推。）默认值为 65536。请注意，当序列化或反序列化数组时，每个数组项都计为一个单独的对象。此外还应注意，一些对象可以有大内存表示形式，因此，单独使用此配额可能不足以防范拒绝服务攻击。有关详细信息，请参见[数据的安全考虑事项](https://msdn.microsoft.com/zh-cn/library/ms733135(v=vs.110).aspx).如果需要增加此配额以至超出默认值，则一定要在发送（序列化）和接收（反序列化）方同时增加此配额，原因是在读取和写入数据时会此配额同时应用于发送方和接收方。

### 

[往返行程](# "折叠")

在一次操作中对对象进行反序列化和重新序列化时将发生往返行程。因此，往返行程是从 XML 到对象实例，然后再返回到 XML 流。

一些 **DataContractSerializer** 构造函数重载具有 *ignoreExtensionDataObject* 参数，该参数默认设置为 **false**。在此默认模式中，对于一个往返行程，可以将数据从数据协定的较新版本发送到较旧版本然后再返回到较新版本而不会出现任何损失，前提是数据协定实现 [IExtensibleDataObject](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.iextensibledataobject(v=vs.110).aspx) 接口。例如，假设 Person 数据协定的版本 1 包含 Name 和 PhoneNumber 数据成员，并且版本 2 添加 Nickname 成员。如果在从版本 2 发送信息到版本 1 时实现 **，则存储 IExtensibleDataObject 数据，并在再次序列化数据时再次发出这些数据，因此在往返行程中不会出现数据丢失。**更多信息，请参见和Nickname。有关详细信息，请参见[向前兼容的数据协定](https://msdn.microsoft.com/zh-cn/library/ms731083(v=vs.110).aspx) 和 [数据协定版本管理](https://msdn.microsoft.com/zh-cn/library/ms731138(v=vs.110).aspx)。

#### 

[往返行程的安全性和架构有效性问题](# "折叠")

往返行程可能会涉及到一些安全性问题。例如，反序列化和存储大量外来数据可能存在安全风险。重新发出无法验证的数据可能会存在安全问题，尤其是在涉及数字签名的情况下。例如，在前面的方案中，版本 1 终结点可能会对包含恶意数据的 Nickname 值进行签名。最后，还可能存在架构有效性问题：终结点可能需要始终发出严格符合其声明的协定并且没有任何额外值的数据。在前面的示例中，版本 1 终结点的协定声明该终结点仅发出 Name 和 PhoneNumber，并且如果正在使用构造验证，则发出额外的 Nickname 值将导致验证失败。

#### 

[启用和禁用往返行程](# "折叠")

要关闭往返行程，请不要实现 [IExtensibleDataObject](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.iextensibledataobject(v=vs.110).aspx) 接口。如果您无法控制相应的类型，则将 *ignoreExtensionDataObject* 参数设置为 **true** 也可获得同样的效果。

### 

[对象图保留](# "折叠")

通常，序列化程序并不关心对象标识，如在下面的代码中所示。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-7)

```
[DataContract]
public class PurchaseOrder
{
    [DataMember]
    public Address billTo;
    [DataMember]
    public Address shipTo;
}

[DataContract]
public class Address
{
    [DataMember]
    public string street;
}
```

下面的代码创建一份订单。

[C\#]()

[VB](https://msdn.microsoft.com/zh-cn/library/ms731073(v=vs.110).aspx?cs-save-lang=1&cs-lang=vb#code-snippet-8)

```
//Construct a purchase order:
Address adr = new Address();
adr.street = "123 Main St.";
PurchaseOrder po = new PurchaseOrder();
po.billTo = adr;
po.shipTo = adr;
```

请注意，将 billTo 和 shipTo 字段设置为同一个对象实例。但是，生成的 XML 会复制重复的信息，并与下面的 XML 类似。

```
<PurchaseOrder>
  <billTo><street>123 Main St.</street></billTo>
  <shipTo><street>123 Main St.</street></shipTo>
</PurchaseOrder>
```

不过，此方法具有以下可能不需要的特征：

-   性能。复制数据的效率低。

-   循环引用。如果对象引用自身，甚至通过其他对象引用自身，则通过复制进行序列化会导致无限循环。（如果发生这种状况，序列化程序将引发 [SerializationException](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.serializationexception(v=vs.110).aspx)。）

-   语义。有时，一定要记住这一点：两个引用指向的是同一个对象而不是两个相同的对象。

有关这些原因，一些 **DataContractSerializer** 构造函数重载具有 *preserveObjectReferences* 参数（默认值为 **false**）。在将此参数设置为 **true** 时，将使用只有 WCF 才可以理解的编码引用的特殊方法。当设置为 **true** 时，XML 代码示例现在如下所示。

```
<PurchaseOrder ser:id="1">
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>
  <shipTo ser:ref="2"/>
</PurchaseOrder>
```

“ser”命名空间引用标准序列化命名空间 http://schemas.microsoft.com/2003/10/Serialization/。每一段数据只进行一次序列化并获得一个 ID 号，后续使用会导致引用已序列化的数据。

[TABLE]

了解此模式的限制是很重要的：

-    **DataContractSerializer** 在 *preserveObjectReferences* 设置为 **true** 的情况下生成的 XML 与任何其他技术都无法进行交互，仅可以由另一个其 *preserveObjectReferences* 也设置为 **true** 的 **DataContractSerializer** 实例进行访问。

-   元数据（架构）不支持此功能。生成的架构仅对 *preserveObjectReferences* 设置为 **false** 的情况有效。

-   此功能可能导致序列化和反序列化进程运行速度减慢。尽管不必复制数据，但是在此模式中必须执行额外的对象比较。

[TABLE]

### 

[指定数据协定代理项](# "折叠")

一些 **DataContractSerializer** 构造函数重载具有 *dataContractSurrogate* 参数，该参数可以设置为 **null**。此外，可以使用它来指定数据协定代理项，数据协定代理项是一种实现 [IDataContractSurrogate](https://msdn.microsoft.com/zh-cn/library/system.runtime.serialization.idatacontractsurrogate(v=vs.110).aspx) 接口的类型。然后可以使用该接口来自定义序列化和反序列化进程。有关详细信息，请参见[数据协定代理项](https://msdn.microsoft.com/zh-cn/library/ms733064(v=vs.110).aspx).


